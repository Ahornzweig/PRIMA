# PRIMA

## Checkliste für Leistungsnachweis
© Prof. Dipl.-Ing. Jirka R. Dell'Oro-Friedl, HFU

| Nr | Bezeichnung           | Inhalt                                                                                                                                                                                                                                                                         |
|---:|-----------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|    | Titel                 | [Quest of the GirlHero]
|    | Name                  | Sarah Lönnqvist
|    | Matrikelnummer        | 259116
|  1 | Nutzerinteraktion     | Der Nutzer kann auf der Startseite auf New Game, Load Game und How to play klicken. New game führt ihn auf eine Seite, in der er seinen Namen eingeben und dann auf Start klicken kann. Load Game gibt einem die Auswahl, eines der Level oder einen gespeicherten Spielstand zu laden. Auf der How to Play-Seite werden einem die Steuerung und die Regeln des Spiels erklärt. Während des Spiels kann man auf Pause und Speichern klicken, um das Spiel zu pausieren und falls man will zu speichern. Man kann dann entweder weiter spielen oder aufhören. Im Spiel bewegt der Nutzer die Figur über die A und D Tasten. Durch die Bewegung der Maus wird die Richtung, in die der Stab zeigt, geändert. Mit einem Mausklick kann man dann einen Angriff abfeuern. Mit der 1 oder 2 Taste kann man zwischen zwei verschiedenen Angriffen wechseln. Nach dem erfolgreichen Beenden des letzten Levels kann der Spieler das Spiel durch den Endscreen schließen. Stirbt der spieler, muss er das Spiel neu starten.                                                                                                                                         |
|  2 | Objektinteraktion     | Der Hauptbestandteil der Kollisionsüberprüfung ist die getRectWorld-Methode. Sie liefert ein Rechteck mit der Position und Größe eines Objektes. Über die Methode checkCollision kann überprüft werden, ob sich die Vektor2-Translation der Instanz in dem gelieferten Rechteck einer anderen Instanz befinden. checkCollison wird über die Update-Methode mancher Klassen aufgerufen. In checkCollision wird dann die getRectWorld-Mmethode einer bestimmten Instanz, welche die Methode besitzt, aufgerufen. Update ist an den game Loop gebunden, der in main gesetzt wurde. Jede Instanz von Girl überprüft die Floor-Instanzen. EnemyAttack-Instanzen überprüfen die Girl-Instanz und Attack die Enemy-Instanzen                                                                                                                                                                              |
|  3 | Objektanzahl variabel | In der main funktion werden eine Kamera, der game-Node, der level-Node, der girl-Node und der viewport erstellt. Main wird aufgerufen, sobald das Laden der Leveldaten beendet wurde. Die Leveldaten werden geladen, sobald der Spieler auf Start oder eine Ladeoption im Startmenü klickt. Bei der Erstellung des Levelknotens wird eine weitere Funktion aufgerufen, die das level baut(buildLevel). In der Funktion werden der backgrounds-, natures-, enemies- und tiles-Knoten erstellt. In backgrounds sind alle background:Object Knoten, in natures alle nature:Object Knoten, in enemies alle enemy:Enemy Knoten und in tiles alle floor:Floor Knoten. Die Anzahl dieser Objekte ist von der levelData-Datei abhängig. Diese Objekte werden auch in der buildLevel-Funktion erstellt, sowie energyBall:Attack und waterArrow:Attack. Die Enemy-Instanzen generieren jeweils eine EnemyAttack Instanz welche eine Verbindung zu dem jeweiligen enemy hat. Zur Laufzeit werden nur die Translation der einzelnen Instanzen (von Object, Floor, Enemy, Attack, EnemyAttack) verändert, um nicht dauernd Neue erstellen zu müssen und so Performanceprobleme zu minimieren.                                                                                                                                                       |
|  4 | Szenenhierarchie      | Der oberste Knoten ist das game, dann folgt das Level. In dem Level befinden sich girl:Girl(der Spieler Charakter), backgrounds, natures, enemies, tiles und die Attacken (energyBall:Attack, waterArrow:Attack). Backgrounds beinhaltet alle erstellten background:Object Knoten, natures beinhaltet alle erstellten nature:Object Knoten, enemies beinhaltet alle erstellten enemy:Enemy Knoten und tiles beinhaltet alle erstellten floor:Floor Knoten. Jede Enemy-Instanz generiert dann noch eine Instanz von EnemyAttack; die dem level angehangen wird.                                                                                                            |
|  5 | Sound                 | Während des gesamten Spiels läuft eine Hintergrundmusik, die die Atmosphäre unterstützen soll. Ein Explosions- und ein Splash-Sound sollen dem Treffen einer Attacke verdeutlichen. Das Springen wird durch ein Jump-Geräusch verdeutlicht.   
|  6 | GUI                   | Der Nutzer kann vor dem Start des Spiels auswählen, ob er neu beginnen, ein Level oder einen Spielstand laden will. Zusätzlich besteht die Möglichkeit sich die Steuerung anzuschauen. Wird ein neues Spiel gestartet, kann der Nutzer seine gewünschten Namen eingeben. Während des Spiels kann man jederzeit speichern. Auch kann der Spieler über das Interface immer sehen, welche Attacke er ausgewählt hat wie viele Lebenspunkte er noch hat und wie viele Gegner er besiegt hat. |
|  7 | Externe Daten         | In gameData.json sind die Anzahl der Level, sowie ihr Aufbau beschrieben. Dazu gehören der Name des Levels, welcher beim ersten Laden des Spiels für den Levelknoten festgelegt wird, der Index des nächsten Levels, er ermöglicht den Übergang zum nächsten Level (und kann somit auch die Reihenfolge ändern). Die Anfangsposition der Kamera und des Spielecharakters sind auch im jeweiligen level gespeichert sowie der x-Abstand der Kamera zum Spieler. Die Parameter für den Aufbau des Levels sind ground,enemys(falsch geschrieben), nature und background. Ground beinhaltet die Parameter Transform, mit der Skallierung und Position aller Boden(floor)-Knoten, sowie einen Index für die Transformwerte der zu Beginn zu plazierenden Bodenknoten. Enemys enthält ein Array mit allen Gegnern. Jeder Gegner hat einen Namen, der bei der Erstellung des Knotens gesetzt wird. spritsheetData enthält die Informationen, die zum Erstellen der Sprites nötige sind. positions enthält alle Gegnerpositionen, scale die Skalierung und speed die Geschwindigkeit des Gegners. Alle werden bei der Erstellung des jeweiligen Levels verwendet. Nature ist genau wie enemys aufgebaut nur dass es keine Geschwindigkeit gibt. Background ist auch so aufgebaut, hier kommen jedoch noch Z für die Positionierung auf der z-Achse und eine id für das Hintergrundbild hinzu.   
|  8 | Verhaltensklassen     | Es gibt die Klassen Objects, MovingObject und Floor. Objects wird für Objekte genutzt, die sich nicht selbst bewegen und nur einen (Starren) Sprite Nutzen. Sie haben eine Update-Methode, die an den game loop gebunden ist. Darin wird überprüft, ob die Instanz verschoben werden muss(da sie außer Sichtweite ist). Stimmt das zu, wird sie über moveObject verschoben. Über die Methode generateSprites kann man einer Instanz einen Sprite zuweisen. MovingObject besitzt die Methoden show und act. Über show kann man einen bestimmten sprite aktivieren. Mit act wird überprüft, welche Aktion gerade verwendet wird und daraufhin das Verhalten der Instanz angepasst (z.B. beim springen die y geschwindigkeit hochsetzen). Floor ist die aus dem Kurs bekannte Klasse, die etwas erweitert wurde. Sie besitzt die Methoden getRectWorld moveFloor und update. update und moveFloor funktionieren prinzipiel wie in Object haben jedoch andere Werte. getRectWorld gibt ein Rechteck mit der Position und Größe der Instanz zurück.                                                                                    |
|  9 | Subklassen            |MovingObject hat vier Subklassen: Girl, Enemy, Attack und EnemyAttack. Außerdem erben alle Klassen von Fudge.Node. Girl hat die Methoden: generateSprites, um mehrere verschiedene Animationen zu erstellen, checkCollision um die Kollision mit den Floor-Instazen zu überprüfen, getRotatio,rotateZ und setRotation um den Winkel des Arms zu verändern,  getRectWorld, die von den EnemyAttack-Instanzen aufgerufen wird, um ein Rechteck mit der Position und der Größe der Instanz zu erzeugen und updata, welches an den game Loop gebunden ist. die translation wird geupdated und checkCollision wird aufgerufen. Enemy hat wie girl eine generateSprites, getRectWorld und update Methode. getRectWorld wird von den Attack-Instanzen aufgerufen. Zusätzlich hat es eine moveEnemy-Methode, die die Gegner im Bezug zur Kammeraposition verschiebt und ein edefeated-Methode, die eine Position aus den möglichen Positionen entfernt und die Intanz verschiebt. Attack besitzt auch eine generateSprites, checkCollision und update Methode. Zusätzlich gibt es die use methode, die die Position, Rotation und Geschwindigkeit der Instanz anpasst. Zusätzlich sorgt sie dafür, dass die Attacke nach einer gewissen Zeit verschwindet. Die Explode-Methode wird durch use oder checkCollision aufgerufen und entfernt die Instanz aus dem level. EnemyAttack ist genau wie Attack aufgabaut, nur dass hier alle Werte an eine Enemy-Instanz gebunden sind.|
| 10 | Maße & Positionen     |Die Spielfigur ist 1 groß und die Gegner auf 0.5 skaliert. Die Welt wird vom Ursprung aus aufgebaut. Die positive x-Richtung ist rechts und die Negative linke. Die Positive y richtung ist oben. Der Boden wird über die Oberkannte plaziert und alle anderen Objekte über die Unterkannte, sodass wenn die Spielerfigur und der Boden beide auf y = 0 gesetzt sind, die Figur auf dem Boden steht. Der Wert für die Spilfiegur wurde gewählt, um alle anderen Größen leicht in relation zu setzen.                                                              |
| 11 | Event-System          |  Das Event-System wird verwendet um das Drücken von Buttons oder den Klick der Maus abzugreifen. Durch das keydown-event wird handleKeyboard und handleAttack aufgerufen sie sind für die Richtung des Spielers so wie die Auswahl der Attacke zuständig. keyup ruft handleKeyboard auf. Mousemove ruft armMovement und click ruft attack auf. Sie sind da um die rotation des arms zu endern, so wie die ausgewählte attacke einzusetzen. Zusätzlich wird auf den Loop noch ein eventlistener gesetzt, der pro Frame update aufruft. Weitere cklick events sind auf den Buttons des User-Interfaces, welche Elemente ein- und ausblenden.                                                                                                                                                                                |

## Abgabeformat
* Fasse die Konzeption als ein wohlformatiertes Designdokument in PDF zusammen!
* Platziere einen Link in der Readme-Datei deines PRIMA-Repositories auf Github auf die fertige und in Github-Pages lauffähige Anwendung.
* Platziere ebenso Links zu den Stellen in deinem Repository, an denen der Quellcode und das Designdokument zu finden sind.
* Stelle zudem auf diese Art dort auch ein gepacktes Archiv zur Verfügung, welches folgende Daten enthält
  * Das Designdokument 
  * Die Projektordner inklusive aller erforderlichen Dateien, also auch Bild- und Audiodaten
  * Eine kurze Anleitung zur Installation der Anwendung unter Berücksichtigung erforderlicher Dienste (z.B. Heroku, MongoDB etc.) 
  * Eine kurze Anleitung zur Interaktion mit der Anwendung
